<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>나도 eBPF 프로그램을 만들어 볼 수 있을까? | CH Engineering</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="나도 eBPF 프로그램을 만들어 볼 수 있을까?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="리눅스 커널 내부 TCP 통신을 위한 시스템콜을 추적하는 간단한 eBPF 프로그램을 직접 작성해 보면서, eBPF 개발 생태계와 주변에 어떤것들이 있는지 공부해 본 내용을 공유한다." />
<meta property="og:description" content="리눅스 커널 내부 TCP 통신을 위한 시스템콜을 추적하는 간단한 eBPF 프로그램을 직접 작성해 보면서, eBPF 개발 생태계와 주변에 어떤것들이 있는지 공부해 본 내용을 공유한다." />
<link rel="canonical" href="https://tech.k10n.me/blog/2024/08/25/welcome-to-jekyll.html" />
<meta property="og:url" content="https://tech.k10n.me/blog/2024/08/25/welcome-to-jekyll.html" />
<meta property="og:site_name" content="CH Engineering" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-25T01:53:02+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="나도 eBPF 프로그램을 만들어 볼 수 있을까?" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-07-06T23:48:17+00:00","datePublished":"2024-08-25T01:53:02+00:00","description":"리눅스 커널 내부 TCP 통신을 위한 시스템콜을 추적하는 간단한 eBPF 프로그램을 직접 작성해 보면서, eBPF 개발 생태계와 주변에 어떤것들이 있는지 공부해 본 내용을 공유한다.","headline":"나도 eBPF 프로그램을 만들어 볼 수 있을까?","mainEntityOfPage":{"@type":"WebPage","@id":"https://tech.k10n.me/blog/2024/08/25/welcome-to-jekyll.html"},"url":"https://tech.k10n.me/blog/2024/08/25/welcome-to-jekyll.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://tech.k10n.me/feed.xml" title="CH Engineering" />
</head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">CH Engineering</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/about/">About</a>
  <a class="nav-item" href="/archive.html">Archive</a>
  <a class="nav-item" href="/tags.html">Tags</a>
</div>

      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div>
  <div class="post-meta-line">
    <span class="post-meta">2024 Aug 25, 10 mins</span><span class="post-tags-inline"><a href="/tags/#network" class="tag-small">Network</a><a href="/tags/#linux" class="tag-small">Linux</a><a href="/tags/#ebpf" class="tag-small">eBPF</a></span></div><h1 class="page-heading">나도 eBPF 프로그램을 만들어 볼 수 있을까?</h1><div id="table-of-contents">
      <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#ebpf-가-뭔가요-에-대한-개인적인-생각">“eBPF” 가 뭔가요? 에 대한 개인적인 생각..</a></li>
<li class="toc-entry toc-h2"><a href="#ebpf를-활용해-만들어-볼-네트워크-관측-도구">eBPF를 활용해 만들어 볼 네트워크 관측 도구</a>
<ul>
<li class="toc-entry toc-h3"><a href="#배경지식">배경지식</a>
<ul>
<li class="toc-entry toc-h4"><a href="#kprobe-kretprobe---kernel-probes">kprobe, kretprobe - kernel probes</a></li>
<li class="toc-entry toc-h4"><a href="#kernel-tracepoints---내가-확인해-볼-수-있는-커널-함수들-목록은-어디에-있지">Kernel Tracepoints - 내가 확인해 볼 수 있는 커널 함수들 목록은 어디에 있지?</a></li>
<li class="toc-entry toc-h4"><a href="#bccbpf-compiler-collection---ebpf-프로그램-툴킷">BCC(BPF Compiler Collection) - eBPF 프로그램 툴킷</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#예제-프로젝트-소개---tcp_monitor">예제 프로젝트 소개 - tcp_monitor</a>
<ul>
<li class="toc-entry toc-h3"><a href="#준비물-lima---리눅스-가상화-도구">준비물: Lima - 리눅스 가상화 도구</a></li>
<li class="toc-entry toc-h3"><a href="#tcp_monitor-프로그램-자세히-살펴보기">tcp_monitor 프로그램 자세히 살펴보기</a></li>
<li class="toc-entry toc-h3"><a href="#bpf-프로그램-상태-조회">BPF 프로그램 상태 조회</a></li>
<li class="toc-entry toc-h3"><a href="#bpf-프로그램에서-사용중인-데이터-살펴보기">BPF 프로그램에서 사용중인 데이터 살펴보기</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#소감">소감</a></li>
<li class="toc-entry toc-h2"><a href="#함께보면-좋은-내용">함께보면 좋은 내용</a></li>
</ul>
    </div>
    <hr class="toc-divider">
    <div id="markdown-content">
      <p>최근에 팀 내에서 꽤 도전적인 네트워크 관측가능성 목표들을 설정하고, 업무들을 진행해 보고 있다.
여러 워크로드로부터 발생하는 네트워크 트래픽을 좀 더 투명하게 살펴보기 위한 방법을 마련하는 것인데,</p>

<p>‘오픈소스 도구를 쓸 까.. 직접 만들어 볼 수는 없을까..’ 고민하던 중에 관심이 많았던 eBPF를 활용해서,
우리가 직접 만든 코드로 네트워크 트래픽을 측정하면 어떨까 하는 마음에 이리저리 혼자서 리서치 해 본 내용을 공유한다.</p>

<p>대부분의 클라우드 프로바이더들이 제공하는 네트워크 관측가능성 상품들은 (예. AWS VPC Flowlog) 프로바이더 계층에서 측정된 데이터를 제공해 주므로 훌륭한 도구이긴 하지만, 굉장히 비싸서 실제 환경에 도입하기에는 다소 어려운 점이 있다.</p>

<p>그리고.. 인터넷을 통해 네트워크 관측 가능성을 위한 오픈소스 도구들을 찾아보면 여러가지가 나오긴 하지만, 원하는 수준의 도구는 아직 찾지 못했다.</p>

<p>원하는 바에 가장 근접한 오픈소스 도구로는 옆 팀원분이 소개해 준 <strong><a href="https://coroot.com/">coroot</a></strong> 라는 도구가 있는데 목표를 달성하는 방식도 내가 지향하는 방향과 가깝다고 생각했다.</p>

<p>이 기술적 방향에 좀 더 확신이 생겨서 열심히 공부해 보면서, eBPF 생태계에 대해서 조금 더 알게 된 내용들을 공유한다.
스터디 결과 내용은 개인 저장소로 올려두었음. <a href="https://github.com/Ashon/_study-ebpf-and-bcc">https://github.com/Ashon/_study-ebpf-and-bcc</a></p>

<blockquote>
  <p>해당 글에서는 eBPF 기술 자체에 대한 소개는 많지 않습니다.</p>

  <p>eBPF 기술에 대한 약간의 배경지식을 가지고, 뭔가 도구를 직접 만들어 보고 싶은 분이나,
eBPF의 활용 사례들은 어떤게 있을 지 감을 잡는 분들에게 조금 더 도움이 될 것 같습니다.</p>

  <p>제가 리눅스 커널에 대한 지식이 많지 않은 상태에서 필요한 내용들을 찾아가면서 공부한 내용이다 보니, 글 내용에서는 이론적 깊이가 다소 얕을 수 있습니다.</p>

  <p>eBPF 관련 도구를 도입 할 예정이거나, 공부하려는 분들이, 이 글을 통해서 eBPF 기술을 활용하는데 조금 더 탄력이 붙을 수 있으면 좋겠습니다.</p>

  <p>다양한 의견과 오류에 대한 수정은 댓글로 알려주시면 저도 더 공부 해 보도록 하겠습니다. 감사합니다.</p>
</blockquote>

<h2 id="ebpf-가-뭔가요-에-대한-개인적인-생각">“eBPF” 가 뭔가요? 에 대한 개인적인 생각..</h2>

<p>eBPF에 대한 자세한 내용은 아래 링크를 참조.</p>

<ul>
  <li><a href="https://ebpf.io/what-is-ebpf/">What is eBPF? An Introduction and Deep Dive into the eBPF Technology</a></li>
  <li><a href="https://www.kernel.org/doc/html/v5.17/bpf/index.html#">BPF Documentation — The Linux Kernel  documentation</a></li>
</ul>

<p>리눅스 커널 내부에 사용자 프로그램을 배치해서, 커널 내부의 상태들을 사용자가 원하는 대로 파악할 수 있게 해 주는 강력한 관측 가능성 기술이다.</p>

<p>매우 강력한 만큼 eBPF를 사용하기 위한 진입 장벽도 생각보다 높은 편이긴 해서, 일반적으로는 eBPF를 활용한 오픈소스 구현체를 레버리지해서 사용하는 경우가 많은 것 같고, 내가 생각해 볼 때 시작이 어려운 이유를 좀 생각해 봤다.</p>

<ul>
  <li><strong>“eBPF”</strong> 는 커널 내부를 관측하는 기술 자체를 의미하는 용어 (BPF 기술로부터 발전)</li>
  <li><strong>“eBPF를 사용한다”</strong> 라는 말은…
    <ul>
      <li>eBPF 기술을 활용해서,</li>
      <li>내가 직접 <strong>“커널 내부의 관측가능성을 달성하는 프로그램을 구현”</strong>해 낸다는 말이라고 생각함.
        <blockquote>
          <p><del>엄밀히 말하면 관측가능성 문제만 푸는건 아님</del></p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>그러므로, 커널 내부의 어떤 부분을 관측해야 할 지 사용자(개발자)가 알아야 함.
    <ul>
      <li>‘커널이 어떻게 동작하는지를 알아야 관측할 대상을 지정할 수 있다.’
        <ul>
          <li>다른말로… ‘커널의 어떤 부분을 관측할 수 있는지 내가 알아야 한다.’
            <blockquote>
              <p><del>… 쉽지않아.</del></p>
            </blockquote>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>현대의 리눅스 커널<del>(옛날에도 그랬지만)</del>은 정말 넓고 다양한 기술들을 담고 있으므로 커널을 공부해야지 하는 생각을 하면 시작부터 머리가 아득한데.. 목표치를 낮춰서 접근 할 필요가 있음.</p>

<ul>
  <li>어차피 한사람이 모든걸 다 알수는 없음..</li>
  <li>리눅스 커널 안의 특정 부분 (네트워킹, 그 중에서도 TCP.. 예를 들자면) 을 좀 공부해 보고…</li>
  <li>이 부분의 특정 지점을 공부해서 eBPF 프로그램을 만들어 본다거나..
    <blockquote>
      <p><del>(이것도 난이도가 있긴 해…)</del></p>
    </blockquote>
  </li>
</ul>

<p>그래도 이런 식의 접근이라면.. (물론 TCP 자체를 아는것은 요즘 시대에서는 꽤 난이도가 있는 일이지만),
한번 비벼볼 만 하다고 생각함. <del>(그리고 우리에겐 ChatGPT가 있다.)</del></p>

<p>뿐만아니라, eBPF 기술 안에도 굉장히 넓은 세계가 있다.</p>

<blockquote>
  <p>XDP, 커널의 네트워킹 성능을 우회하여 초고속으로 데이터를 주고받을 수 있도록 하는 기술.. 이라거나..</p>
</blockquote>

<p>여기서는 eBPF를 이용해 <a href="https://docs.kernel.org/trace/kprobes.html">kprobe(kernel probe)</a> 를 등록해서, 커널 내부의 네트워크 가시성을 확보하기 위한 내용을 진행했다.</p>

<h2 id="ebpf를-활용해-만들어-볼-네트워크-관측-도구">eBPF를 활용해 만들어 볼 네트워크 관측 도구</h2>

<p>보편적인 http 웹서버 애플리케이션들은 리눅스 커널 TCP 스택의 tcp_sendmsg, tcp_recvmsg 시스템콜을 이용해 네트워크 통신을 수행한다. (<del>QUIC은 UDP니까 제외합니다.</del>)</p>

<blockquote>
  <p>엄격하게 따져보면 웹서버들은 더 다양한 tcp 시스템콜 사용할텐데, 소개하는 자리니까 간단히 tcp_sendmsg, tcp_recvmsg만 살펴보자.</p>
</blockquote>

<p>나는 저 tcp_sendmsg, tcp_recvmsg 함수에 kprobe를 붙여서, 여러 웹서버들이 주고받는 데이터로부터 SRC IP, DST IP, payload size 등을 측정하는 애플리케이션을 만들어 보았다.</p>

<p><img src="/assets/2024-08-25/fig1.png" alt="" /></p>

<p>작성하는 애플리케이션의 기능은 아주 단순하다.</p>

<ul>
  <li>SRC IP, DST IP 정보가 있으면, 어떤 네트워크 구간을 이동하는지 알 수 있다.</li>
</ul>

<p>하지만 단순한 기능을 활용해서 다른 모니터링 시스템과 강력한 시너지를 낼 수 있게 만들 수 있을 것이다.</p>

<ul>
  <li>이 정보를 활용하면, 특정 워크로드가 어떤 네트워크 경로로 통신을 하는지 확인할 수 있음.</li>
  <li>비용 최적화, 경로 최적화를 하는데 사용할 수 있음.</li>
  <li>장애 발생 시 네트워크 구간을 투명하게 확인해서 트러블슈팅 할 수 있게 됨.</li>
  <li>이 정보를 별도 데이터베이스로 수집하고, IP 프로파일링 도구를 활용하면 더더욱 강력한 모니터링이 가능해 진다.
    <ul>
      <li>IP profiling: k8s pod들을 확인한다거나, VM 인스턴스들의 정체, 외부 IP를 파악하는 용도</li>
    </ul>
  </li>
</ul>

<h3 id="배경지식">배경지식</h3>

<h4 id="kprobe-kretprobe---kernel-probes">kprobe, kretprobe - kernel probes</h4>

<p>kprobe는 kernel probe의 줄임말로 여러 커널 함수들의 진입점에 어떤 값이 들어가는지 확인할 수 있도록 하는 관측 기술이다. (<a href="https://docs.kernel.org/trace/kprobes.html">링크 - Kernel Probes @ kernel.org</a>)</p>

<ul>
  <li>함수 진입점을 살펴볼 때는 kprobe를 사용할 수 있고,</li>
  <li>함수 응답값을 살펴볼 때는 kretprobe를 사용하면 된다. (kernel return probe)</li>
</ul>

<p><img src="/assets/2024-08-25/fig2.png" alt="" /></p>

<p>대략… 이렇게 생겼다.</p>

<p>kprobe, kretprobe는 커널 함수 앞뒤에 사용자가 작성한 함수를 후킹하는 방식으로 관측가능성을 제공하는데.. 사용자는 아래 준비물들을 가지고 커널 내부를 관찰할 수 있다.</p>

<ul>
  <li>관찰하고자 하는 커널 함수 -&gt; <strong>어떤 함수를 디버깅 할 지 알아야 함.</strong></li>
  <li>관찰값을 어떻게 처리할 것인지 핸들링하는 함수 -&gt; <strong>후킹된 값을 어떻게 볼 지 작성해야 함.</strong></li>
</ul>

<h4 id="kernel-tracepoints---내가-확인해-볼-수-있는-커널-함수들-목록은-어디에-있지">Kernel Tracepoints - 내가 확인해 볼 수 있는 커널 함수들 목록은 어디에 있지?</h4>

<p>리눅스 커널은 문제가 발생했을 때 내부 상태를 들여다보거나, 복구하기 위한 별도의 기능을 파일시스템 형태로 제공한다.</p>

<p>대부분은 서버 내부에 <strong>/sys/kernel/debug</strong> 라는 디렉토리 하위에 debugFS가 마운트 되어 있을텐데, 여기서 내가 계측하고자 하는 커널 함수들을 확인할 수 있다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 만약 서버에 debugFS가 마운트 되어 있지 않다면, 직접 마운트 해 주면 된다.</span>
<span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-t</span> debugfs none /sys/kernel/debug
</code></pre></div></div>

<p>debugFS를 보면 다양한 파일들이 보이는데 일단 eBPF에서 추적 가능한 함수 목록을 찾기 위해서는 <strong>/sys/kernel/debug/tracing/</strong> 디렉토리 내의 파일들을 찾아보면 된다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 트레이싱 할 수 있는 함수 목록들이 적힌 파일들</span>
<span class="nv">$ </span>find /sys/kernel/debug <span class="nt">-name</span> avail<span class="k">*</span>

/sys/kernel/debug/tracing/available_filter_functions_addrs
/sys/kernel/debug/tracing/available_filter_functions  <span class="c"># 추적 가능한 함수 목록</span>
/sys/kernel/debug/tracing/available_tracers
/sys/kernel/debug/tracing/available_events
/sys/kernel/debug/tracing/rv/available_reactors
/sys/kernel/debug/tracing/rv/available_monitors
...
</code></pre></div></div>

<p>아래와 같이 추적가능한 함수 목록에서 필요한 함수들을 찾을 수 있다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 추적 가능한 함수 목록에서 tcp 관련 함수들 찾기</span>
<span class="nv">$ </span><span class="nb">cat</span> /sys/kernel/debug/tracing/available_filter_functions | <span class="nb">grep </span>tcp_

...
tcp_sendmsg
...
tcp_recvmsg
...
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">위에서 조회되는 함수들을 진입점으로 삼아서 커널 내부에서 수행하는 기능을 확인해 보고, 어떻게 계측할 지 결정하면 된다.</code></p>

<h4 id="bccbpf-compiler-collection---ebpf-프로그램-툴킷">BCC(BPF Compiler Collection) - eBPF 프로그램 툴킷</h4>

<p><a href="https://github.com/iovisor/bcc">https://github.com/iovisor/bcc</a></p>

<p><a href="https://www.iovisor.org/">IOvisor</a> 프로젝트에서 관리되는 BPF 프로그램 툴킷인데, 이를 이용하면 사용자(개발자)는 보다 편리하게 ebpf 프로그램을 작성하고 관리할 수 있게 된다.</p>

<p>하는일을 크게 살펴봤을때,</p>

<ul>
  <li>eBPF 프로그램 코드(백엔드) 를 작성하면</li>
  <li>다양한 언어로 eBPF 프로그램(백엔드)에 대한 프론트엔드 인터페이스를 만들수 있게 해 줌.
    <ul>
      <li>eBPF 기술 + 기능을 확장.</li>
    </ul>
  </li>
</ul>

<p>이런게 가능해 진다.</p>

<ul>
  <li>커널 함수의 어떤 기능을 추적하는 eBPF 코드를 작성하고,</li>
  <li>내가 잘 아는 파이썬과 FastAPI를 이용해서,</li>
  <li><strong>eBPF 프로그램이 측정한 값을 HTTP로 노출할 수 있음.</strong></li>
</ul>

<blockquote>
  <p>브렌단 그렉이 과거에 eBPF를 소개하면서 커널계의 브라우저 Javascript Engine 같은 것이라고 소개한 적이 있다. (<a href="https://www.brendangregg.com/blog/2024-03-10/ebpf-documentary.html">링크</a>)</p>

  <p>나는 처음에 저런 비유를 드는것에 도무지 이해가 가지 않았는데, 이번에 BCC로 직접 프로그램을 작성해 보면서, 그제서야 저 비유의 의미를 조금 알게 된 것 같다..</p>
</blockquote>

<h2 id="예제-프로젝트-소개---tcp_monitor">예제 프로젝트 소개 - tcp_monitor</h2>

<p>아래는 eBPF 스터디를 진행해 보면서 작성해 본 프로젝트.</p>

<p><a href="https://github.com/Ashon/_study-ebpf-and-bcc">https://github.com/Ashon/_study-ebpf-and-bcc</a></p>

<ul>
  <li>lima로 vm 정의, 초기 프로비저닝 코드
    <ul>
      <li>VM 정의 템플릿: (<a href="https://github.com/Ashon/_study-ebpf-and-bcc/blob/main/ebpf-dev.tpl.yaml">링크</a>)</li>
      <li>VM 실행 스크립트: (<a href="https://github.com/Ashon/_study-ebpf-and-bcc/blob/main/launch.sh">링크</a>)</li>
    </ul>
  </li>
  <li>eBPF 프로그램 코드 디렉토리 (<a href="https://github.com/Ashon/_study-ebpf-and-bcc/tree/main/workspace">링크</a>)
    <ul>
      <li>docker compose를 활용해서 빌드하고 실행할 수 있음.</li>
      <li>k8s 워커노드에 데몬셋으로 띄워서 테스트 해 보고싶긴 한데.. 일단은 좀 더 디밸롭 해 보기</li>
    </ul>
  </li>
  <li>개발환경 구축 가이드는 (<a href="https://github.com/Ashon/_study-ebpf-and-bcc/tree/main?tab=readme-ov-file#22-define--start-development-vm-instance">링크</a>) 참고</li>
</ul>

<h3 id="준비물-lima---리눅스-가상화-도구">준비물: Lima - 리눅스 가상화 도구</h3>

<p>맥 위에서 eBPF개발을 해 보려면 리눅스 가상머신이 필요하다.</p>

<p>Lima는 MacOS 안에서 Linux VM을 구동할 수 있게 해 주는 가상화 API인데, 지금까지 파악해 본 내용으로는 가장 사용성이 좋고, 기술적으로도 많이 오픈되어 있는 것 같아서 요걸 선택했음.</p>

<p><img src="/assets/2024-08-25/fig3.png" alt="" /></p>

<p>리눅스 머신 위에서 개발할 때 VSCode Remote Development를 활용하면 좀 더 편리하게 접근할 수 있음.
이제 Lima를 가지고 Linux VM을 올려서, VM 위에서 eBPF 프로그램을 만들어 볼 수 있다.</p>

<ul>
  <li><a href="https://github.com/lima-vm/lima">Github lima-vm/lima</a></li>
  <li><a href="https://github.com/lima-vm/socket_vmnet">Github lima-vm/socket_vmnet</a></li>
</ul>

<h3 id="tcp_monitor-프로그램-자세히-살펴보기">tcp_monitor 프로그램 자세히 살펴보기</h3>

<p>이번에 작성한 프로그램을 좀 더 자세히 들여다 보면…</p>

<p><img src="/assets/2024-08-25/fig4.png" alt="" /></p>

<p>eBPF 프로그램 (<a href="https://github.com/Ashon/_study-ebpf-and-bcc/blob/main/tcp_monitor/tcp_monitor.c">Code</a>)</p>

<ul>
  <li>tcp_sendmsg 함수로 들어오는 소켓 구조체 정보에서 필요한 데이터를 계측하는 함수 작성</li>
  <li>tcp_recvmsg 함수로 들어오는 소켓 구조체 정보에서 필요한 데이터를 계측하는 함수 작성</li>
  <li>각 함수에서 src, dst, tcp payload 크기를 추출해서 BPF HASH에 저장.</li>
</ul>

<p>파이썬 프로그램 (<a href="https://github.com/Ashon/_study-ebpf-and-bcc/blob/main/tcp_monitor/tcp_monitor.py">Code</a>)</p>

<ul>
  <li>eBPF 프로그램을 로드하고, 커널 함수에 어태치 함.</li>
  <li>BPF_HASH에서 주기적으로 정보를 추출해서 python dict로 저장</li>
  <li>FastAPI는 트래픽 정보를 저장하는 python dict를 응답하는 API가 존재함.</li>
</ul>

<p>컨테이너 정의 (<a href="https://github.com/Ashon/_study-ebpf-and-bcc/blob/main/tcp_monitor/Dockerfile">Code</a>)</p>

<ul>
  <li>BCC로 작성 된 프로그램을 컨테이너로 빌드할 수 있음.</li>
  <li>런타임 정의는 docker compose를 활용. (<a href="https://github.com/Ashon/_study-ebpf-and-bcc/blob/main/tcp_monitor/docker-compose.yml">Code</a>)
    <ul>
      <li>K8s로 배포 정의를 작성할 때 참고하면 됨.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>코드를 들여다 보면 “MAX_ENTRIES” 나, “ktime_map” 이라는 값들을 볼 수 있는데, 이는 트래픽 계측을
좀 더 정확하고 안전하게 하기 위한 부가 장치들이므로 코드 작성 내용에서는 설명을 하지 않는다.</p>
</blockquote>

<h3 id="bpf-프로그램-상태-조회">BPF 프로그램 상태 조회</h3>

<p>bpftool을 활용하면 커널에 로드된 BPF 프로그램들과 프로그램이 사용중인 데이터들을 쉽게 확인해 볼 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># linux 툴 설치 (우분투를 예시로.. cent계열은 패키지 따로 찾아보세용~)</span>
<span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>linux-tools-<span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span>

<span class="c"># bpf program list 조회</span>
<span class="nv">$ </span><span class="nb">sudo </span>bpftool prog list

...

184: kprobe  name poll_sendmsg  tag 8d470dd2a021dc12  gpl
<span class="c">#                 ^^^^^^^^^^^^ 내가 작성한 함수의 이름</span>
    loaded_at 2024-08-22T20:51:51+0900  uid 0
    xlated 624B  jited 560B  memlock 4096B  map_ids 6,8
<span class="c">#                                           ^^^^^^^^^^^ 해당 함수가 사용하는 BPF MAP ID</span>
    btf_id 81
185: kprobe  name poll_recvmsg  tag 9e1707d2f89dc165  gpl
    loaded_at 2024-08-22T20:51:51+0900  uid 0
    xlated 624B  jited 560B  memlock 4096B  map_ids 6,7
    btf_id 81
</code></pre></div></div>

<p>작성한 ebpf 프로그램들이 잘 올라간 것을 확인할 수 있다.</p>

<h3 id="bpf-프로그램에서-사용중인-데이터-살펴보기">BPF 프로그램에서 사용중인 데이터 살펴보기</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># BPF 프로그램이 사용중인 map들 살펴보기</span>
<span class="nv">$ </span><span class="nb">sudo </span>bpftool map list

...

7: <span class="nb">hash  </span>name recv_bytes  flags 0x0
    key 12B  value 16B  max_entries 300000  memlock 32389744B
    btf_id 81
8: <span class="nb">hash  </span>name send_bytes  flags 0x0
    key 12B  value 16B  max_entries 300000  memlock 32389744B
    btf_id 81
</code></pre></div></div>

<p>tcp_monitor가 사용중인 recv_bytes, send_bytes 맵들이 잘 올라간 것을 볼 수 있음.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 직접 map id를 덤프해서 어떤 데이터가 매핑되어 있는지도 확인할 수 있다.</span>
<span class="c"># 동작중인 애플리케이션 맵을 자세히 관찰해 볼 수 있음.</span>
<span class="nv">$ </span><span class="nb">sudo </span>bpftool map dump <span class="nb">id </span>8
<span class="o">[{</span>
        <span class="s2">"key"</span>: <span class="o">{</span>
            <span class="s2">"src_ip"</span>: 252029120,
            <span class="s2">"dst_ip"</span>: 33925312,
            <span class="s2">"src_port"</span>: 22,
            <span class="s2">"dst_port"</span>: 54357
        <span class="o">}</span>,
        <span class="s2">"value"</span>: <span class="o">{</span>
            <span class="s2">"bytes"</span>: 21120,
            <span class="s2">"timestamp"</span>: 740363868867
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>

<p>bpftool 바이너리를 활용해서 프로그램 상태를 투명하게 볼 수 있는데…</p>

<p>이 말은 굳이 BCC를 사용하지 않더라도, eBPF 프로그램 코드를 Native 로 작성하고, 다른 외부 언어들을 활용해서 BPF MAP을 통해서 데이터를 주고받을 수 있게 됨을 의미한다.</p>

<h2 id="소감">소감</h2>

<p>지금까지,</p>

<ul>
  <li>ebpf에 대한 간단한 소개</li>
  <li>bcc를 활용해서 ebpf 프로그램을 만드는 방법</li>
  <li>bpf 프로그램들의 상태를 추적해 보는 방법</li>
</ul>

<p>들을 알아보았는데…</p>

<ul>
  <li>eBPF는 접근하기 꽤 어려운 기술이긴 하지만.. 요즘에 다양한 학습 도구가 있어서, 꽤 편리하게 접근해 볼 수 있게 되었다.
    <blockquote>
      <p><del>우리에겐 ChatGPT가 있다.</del></p>
    </blockquote>
  </li>
  <li>세상에 다양한 관측가능성 도구들이 있지만…
    <ul>
      <li>eBPF를 활용해서 우리에게 최적화된 메트릭을 수집할 수 있을 것 같은 가능성을 보았음.</li>
    </ul>
  </li>
  <li>BCC는 매우 훌륭하게 eBPF 프로그램을 확장할 수 있게 해 주는 것 같다.</li>
</ul>

<p>이번 내용을 발판삼아 직접 eBPF 작성도 해 보고, 다른 eBPF 프로젝트를 만나면 반가운 마음(?)으로, 코드를 들여다 보면서 또 한 수 배울 수 있도록 하면 좋을 것 같다.</p>

<h2 id="함께보면-좋은-내용">함께보면 좋은 내용</h2>

<ul>
  <li><a href="https://ebpf.io/what-is-ebpf/">What is eBPF? An Introduction and Deep Dive into the eBPF Technology</a></li>
  <li><a href="https://www.kernel.org/doc/html/v5.17/bpf/index.html#">BPF Documentation — The Linux Kernel  documentation</a></li>
  <li><a href="https://blog.cloudflare.com/ko-kr/how-to-drop-10-million-packets-ko-kr">Cloudflare - 초당 천만개의 패킷을 버리는 방법</a>
    <ul>
      <li>eBPF의 XDP 기술을 활용해서 커널 네트워킹 스택에 들어오기도 전에 packet을 다 쳐내버리는 이야기</li>
    </ul>
  </li>
  <li><a href="https://blog.cloudflare.com/introducing-ebpf_exporter">Cloudflare - Introducing ebpf_exporter</a>
    <ul>
      <li>Cloudflare에서 만든 ebpf exporter 를 소개하는 내용</li>
      <li><a href="https://github.com/cloudflare/ebpf_exporter">Github - cloudflare/ebpf_exporter</a></li>
    </ul>
  </li>
</ul>

<p>BCC 관련 내용</p>

<ul>
  <li><a href="https://github.com/iovisor/bcc/blob/master/src/cc/export/helpers.h">bcc helpers</a></li>
  <li><a href="https://github.com/iovisor/bcc/blob/master/src/cc/export/proto.h">bcc protocol structures</a></li>
</ul>

<p>XDP 애플리케이션 예제들</p>

<ul>
  <li><a href="https://github.com/ashhadsheikh/ebpf/blob/master/router.c">XDP로 만든 Router</a></li>
  <li><a href="https://github.com/Netronome/bpf-samples/tree/a7dd7d8c38636dd0a1bb5f2380ce309f314abfe3/l4lb">XDP L4LB 예제</a>
    <ul>
      <li>널리 알려진 오픈소스로는 <a href="https://github.com/facebookincubator/katran">Facebook의 Katran</a> 이 있음</li>
    </ul>
  </li>
  <li><a href="https://github.com/iovisor/bcc/blob/master/examples/networking/xdp/xdp_redirect_cpu.py">XDP를 이용해 패킷처리를 특정 CPU Core에만 할당하도록 처리하는 예제</a></li>
</ul>

<p>그 외 eBPF를 활용한 오픈소스들</p>

<ul>
  <li><a href="https://l3af.io/">L3AF</a>: Linux Foundation에서 관리하는 eBPF Marketplace project.
    <blockquote>
      <p>지금의 Docker 레지스트리같이, eBPF 프로그램들도 마켓플레이스를 통해 다양한 기능들이 제공될 것이라 생각한다.
눈여겨 보는 프로젝트 중 하나.</p>
    </blockquote>
  </li>
  <li><a href="https://cilium.io/">cilium</a>: eBPF XDP 기반 K8s CNI.</li>
  <li>eBPF 기반 관측가능성 도구
    <ul>
      <li><a href="https://github.com/coroot/coroot">coroot</a></li>
      <li><a href="https://github.com/microsoft/retina">retina</a></li>
      <li><a href="https://github.com/sustainable-computing-io/kepler">kepler</a></li>
    </ul>
  </li>
</ul>

    </div>
</div>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper"><div class="social-links"><a href="https://github.com/devchanghwan" title="GitHub">
      <svg class="svg-icon" viewBox="0 0 16 16">
        <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
      </svg>
    </a><a href="https://linkedin.com/in/devchanghwan" title="LinkedIn">
      <svg class="svg-icon" viewBox="0 0 16 16">
        <path fill="currentColor" d="M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854V1.146zm4.943 12.248V6.169H2.542v7.225h2.401zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248-.822 0-1.359.54-1.359 1.248 0 .694.521 1.248 1.327 1.248h.016zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016a5.54 5.54 0 0 1 .016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225h2.4z"/>
      </svg>
    </a><a href="/feed.xml" title="RSS">
    <svg class="svg-icon" viewBox="0 0 16 16">
      <circle fill="currentColor" cx="2" cy="14" r="2"/>
      <path fill="currentColor" d="M1,9c3.31,0,6,2.69,6,6h2C9,11.13,5.87,8,1,8V9z"/>
      <path fill="currentColor" d="M1,5c5.51,0,10,4.49,10,10h2C13,9.48,6.52,3,1,3V5z"/>
    </svg>
  </a>
</div> <h2 class="footer-heading">CH Engineering</h2>
      <small>Experience and Thinking about Software Development</small>
      
      <ul class="contact-list">
        <li class="p-name"></li><li>
            <small>
              <a href="mailto:devchanghwan@gmail.com">devchanghwan@gmail.com</a> |
              <a href="/sitemap.xml" title="sitemap">sitemap</a>
            </small>
          </li></ul>
      
      <div class="footer-col-wrapper">
        <div class="footer-copyright">
          <small>Copyright 2016-2023. Ju-won Lee. All rights reserved.</small>
        </div>
      </div>
    </div>
  </footer>
</body>

</html>
